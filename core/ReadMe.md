DoST 简介
==========
	DoST, Do STMicroelectronics的简称，该项目采用 cmake 来组织整个工程，由于 cmake 跨平台，因此，
该项目应当兼容 cmake 支持的所有平台，使用该项目最佳的环境是：Linux + CMake + Emacs + Git.

DoST 特性
==========
1. 基于 CMake 架构;
2. 跨平台，适应 Linux 平台下的开发;
3. 能同时管理任意套不同型号的ST开发板的工程;
4. 可以智能的更新第三方库（比如：HALLIB）;
5. 支持一键编译，提供 -r 参数的情况下允许重新编译，在同时管理多个工程的情况下允许选择编译哪个工程;
6. 支持一键交叉调试，可保存上一次的调试记录，提供 -r 参数的情况下允许重新调试，在同时管理多个工程的情况下允许选择调试哪个工程;
7. 支持一键烧录，直接执行脚本即可实现烧录程序至开发板的功能;
8. 组件式编程，将共性代码封装起来，在 CMakeLists.txt中使用 find_package()命令即可加载需要的组件;
9. 使用的交叉编译器是 arm-none-eabi-gcc, 当前的版本是 gcc-arm-none-eabi-6-2017-q2-update; 

核心思想
==========
	ST 的开发是一个很有意思的事，它有太多可重用的代码，以及太多无需用户过多关心的代码，比如说：
内存管理的内部实现，文件系统内核源码（FATFS），字库相关的源码，网络相关的组件（LWIP），
实时操作系统（UCOSIII，FreeRTOS），用户图形接口（STemwin） ，USB 驱动等等，这些代码通常都
可以独立出来。我们可能比较关心这些模块提供的接口函数，而不太关心具体的实现，很巧的是这些组件
通常对于ST任意型号的开发板都是一致的，除非这些模块的厂家对其进行升级，否则STM32开发者基本
上可以在ST不同型号的开发板之间重用这些代码。当然还有一些重用率在满足一定条件下也很高的源码，
比如 ARM 提供的 CMSIS，所有的 Cortex-M4 内核的 ST 产品均可以重用同一套 CMSIS。再比如 ST
提供的 HAL 库，所有 STM32F4 系列的产品均可以重用同一套 HAL 库。 
	如果你手头有一块 STM32F407的板，以及一块 STM32F767 的板子，而你又想让两块板子都工作能跑
操作系统 FreeRTOS，在Windows 下的 Keil/MDK 下面，你不得新建两个工程，组织两遍 FreeRTOS 的
源代码，尽管它是一模一样的。组织这些重复的代码会花费我们大量的时间，极大的降低了效率。
	DoST, 其核心思想就是将这些可重用的代码使用Cmake语法，将其封装成组件的形式，用户，
只需在使用到相关的组件时，简单的进行加载，然后就可以愉快的使用这些组件所提供出来的接口函数，
如果你没有去加载这些组建，那么这些组件就不会参与编译，这样的形式使得代码具有高度可裁剪性以及
通用性，对于RAM尤其珍贵的STM32来说，这样的特性更是难能可贵，能节省相当多RAM。使用这样的方案，
用户甚至能同时管理任意多个不同型号ST板子的工程，而又能保持代码的简洁和逻辑的清晰。

顶层目录架构
==========
1. 顶层 CMakeLists.txt 
	是整个系统的 "指挥中心", 它负责规范系统的基本行为, 比如禁止 CMAKE 内部编译, CMAKE 的
版本限制, 创建工程等. 它还负责控制程序的加载顺序, 脚本调度, 以及控制进入子目录的时机等, 这对于整
个系统来说是十分重要的,详细信息参看 程序的加载顺序 章节。

2. core
	DoST 内核的源码，主要是一些脚本，以及组件，DoST 开发者才会关心这个目录，普通
用户一般不需要关心它。

3. .dost.conf 
	DoST 内核中提供给用户配置的接口，用户可以在该目录下对相应的变量进行个性配置，DoST 在工作时
会去加载这些配置。一些需要对 DoST 进行深层次定制的用户才会去修改这个目录下的配置，它会影响内核
的工作方式，所以一般不建议用户去随意修改他们，除非你很确定的知道你自己正在做什么。

4. ST
	该目录就是普通用户最关心的目录，用户创建的 ST 所有型号板子的工程可以在该目录下面按照相应的目录
规则进行创建，由于 DoST 系统可以根据用户在编译时提供的 STM32_CHIP 参数自动选择应当编译哪个子目录下
的工程，因此，用户只需要按照符合实例所示的目录命名规范就可以轻易的创建自己的项目，而且可以同时创建
多个不同的项目。值得说明的是，用户只需要只需要实现个性代码，比如外设相关的驱动，或者项目中某一具体
的功能，而那些共性的代码全部由 DoST 内核提供，用户只需要简单的调用 find_package() 进行加载即可，
详细信息请参看该目录下的源代码的实现。

6. compile.sh
	DoST 的编译脚本，直接运行该脚本，即可立即编译工程，如果你是第一次编译某一型号开发板的源码，
那么系统会提示你输入你想要编译的开发板的型号，之后再次编译时不会再要求你输入型号;如果你需要重新编译
该工程或者编译其他型号的开发板对应的源码，那么可以在运行脚本时加上 -r 参数，此时系统会要求你输入待
编译的开发板的型号，该参数十分重要，DoST 就是依靠这个参数进行解析的ST产品的。

7. debug.sh
	DoST 的调试脚本，直接运行该脚本，即可立即开始调试工程，如果你是第一次调试某一型号开发板的源码，
那么系统会提示你输入你想要调试的开发板的型号，之后再次调试时不会再要求你输入型号;如果你需要重新调试
该项目或者调试另外一个型号的开发板，那么，你在运行调试脚本的同时可以加上 -r 参数，此时系统会要求你输入
待调试的开发板的型号，该参数十分重要，DoST 就是依靠这个参数进行解析的ST产品的。
    
8. burn.sh
	直接运行该脚本，可以将程序烧录到开发板中。

使用 DoST
==========
1. 编译：cd DoST && ./compile.sh
2. 重新编译： cd DoST && ./compile.sh -r
3. 调试：cd DoST && ./debug.sh
4. 重新编译：cd DoST && ./debug.sh -r
5. 烧录：cd DoST && ./burn.sh

备注
==========
	由于近些年 ST 大力主推 HAL 库，并以 Cube 包的形式发布，这将会是将来的发展趋势，这也从侧面反映了
ST 有意想逐渐淘汰掉 FWLIB 固件库，因此，在该系统中不打算去支持 FWLIB，不过由于该系统是基于Cmake 的，
有着相当强大的扩展能力，如果有必要，用户可以仿照 core/Scripts 目录下 HAL 库的解析脚本，自己实现对
FWLIB 固件库的解析。
	由于该系统是我的个人项目，时间有限，一些技术细节可能不能尽述，有对 DoST 感兴趣的朋友如果在使用
DoST 的过程中有遇到技术相关问题的，可在 Github 上提 issues 或者直接给我发送邮件：ytulinjiajun@163.com
